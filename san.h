#ifndef SAN
#define SAN

//! @file   san.h
//! @brief  san - часть библиотеки С, включающая некоторые функции для взаимодействия со строками, написанная Иванишиным Корнеем

#include <stdio.h>
#include <stdlib.h>

//! @brief  Функция, позволяющая определить длину строки в символах
//!
//! @param  str     Указатель на первый элемент строки, длину которой нужно получить
//!
//! @return Число типа size_t, равное длине указанной строки
//!
//! @note   Завершающий нуль-байт не входит в считаемые функцией символы строки

size_t my_strlen (const char str[]);

//! @brief  Функция, осуществлящая поиск в строке элемента с заданным номером в ASCII-таблице
//!
//! @param  str     Указатель на первый элемент строки, в которой осуществляется поиск
//! @param  symcode Код (номер) искомого символы в ASCII-таблице
//!
//! @return Указатель на первый элемент строки с заданным номером в ASCII-таблице, или NULL, если символа с таким кодом в строке нет

char* my_strchr (const char str[], int symcode);

//! @brief  Функция, копирующая содержимое одной строки в другую
//!
//! @param  strto   Указатель на первый элемент строки, в которую производится копирование
//! @param  strfrom Указатель на первый элемент строки, содержимое которой копируется
//!
//! @return Указатель на первый элемент строки, в которую производилось копирование
//!
//! @note   Завершающий нуль-байт тоже копируется
//!
//! @warning    Строка strto должна быть достаточно большой, чтобы уместить все символы строки strfrom (включая нуль-байт); В противном случае поведение функции не определено

char* my_strcpy (char strto[], const char strfrom[]);

//! @brief  Функция, копирующая первыу n байт одной строки в другую строку
//!
//! @param  strto   Указатель на первый элемент строки, в которую производится копирование
//! @param  strfrom Указатель на первый элемент строки, содержимое которой копируется
//! @param  num     Количество первых байт, копируемых из strfrom в strto
//!
//! @return Указатель на первый элемент строки, в которую производилось копирование
//!
//! @warning    Если среди первых n байт строки strfrom нет нуль-байта, у полученной строки будет отсутствовать авершающий нуль-байт
//! @warning    Строка strto должна быть достаточно большой, чтобы уместить все копируемые символы строки strfrom; В противном случае поведение функции не определено

char* my_strncpy (char strto[], const char strfrom[], size_t num);

//! @brief  Функция, присоединяющая содержимое одной строки к другой
//!
//! @param  strto   Указатель на первый элемент строки, к которой присоединяется содержимое другой строки
//! @param  strfrom Указатель на первый элемент строки, содержимое которой присоединяется
//!
//! @return Указатель на первый элемент строки, к которой производилось присоединение
//!
//! @note   Функция переписывает содержимое байта, содержавшего нуль-байт строки strto, а содержимое strfrom присоединяет вместе с завершающим нуль-байтом (который она добавляет сама независимо от его наличия в конце strfrom)
//!
//! @warning    Строка strto должна быть достаточно большой, чтобы уместить все символы исходной strto (без нуль-байта) и все символы строки strfrom (с нуль-байтом); В противном случае поведение функции не определено

char* my_strcat (char strto[], const char strfrom[]);

//! @brief  Функция, присоединяющая первые n байтов одной строки к другой
//!
//! @param  strto   Указатель на первый элемент строки, к которой присоединяется содержимое другой строки
//! @param  strfrom Указатель на первый элемент строки, содержимое которой присоединяется
//! @param  num     Количество первых байт строки strfrom, присоединяемых к strto
//!
//! @return Указатель на первый элемент строки, к которой производилось присоединение
//!
//! @note   Функция переписывает содержимое байта, содержавшего нуль-байт строки strto, а первые n байт strfrom присоединяет, добавляя в качестве n + 1 присединенного байта нуль-байт
//! @note   Если в strfrom меньше чем n символов, присоединено будет все ее содержимое (включая нуль-байт, который функция добавит в конце сама независимо от его наличия в конце strfrom)
//!
//! @warning    Строка strto должна быть достаточно большой, чтобы уместить все символы исходной strto (без нуль-байта) и n байт строки strfrom (с нуль-байтом); В противном случае поведение функции не определено

char* my_strncat (char strto[], const char strfrom[], size_t num);

//! @brief  Функция, считывающая строку из файла
//!
//! @param  str     Указатель на первый элемент строки, в которую записываются считанные символы
//! @param  num     Максимальное количество символов, которое может содержать считанная строка (включая нуль-байт, который функция указывает в конце считанной строки автоматически)
//! @param  file    Указатель на файл, из которого считывается строка
//!
//! @return Указатель на первый элемент считанной строки или NULL, если возникла ошибка или по достижении конца файла не было считано ни одного символа
//!
//! @note   Функция продолжает считывание до символа перехода на следующую строку (который, если будет встречен, будет также внесен в считанную строку) или до конца файла

char* my_fgets (char str[], int num, FILE* file);

//! @brief  Функция, дублирующая указанную строку
//!
//! @param  initstr Указатель на первый элемент дублируемой строки
//!
//! @return Указатель на первый элемент строки-дубликата или NULL, если для хранения дубликата в памяти недостаточно места
//!
//! @note   Функция самостоятельно выделяет память, необходимую для хранения дубликата строки, используя для этого функцию calloc ()

char* my_strdup (const char initstr[]);

//! @brief  Функция, считывающая строку из файла
//!
//! @param  str     Указатель строку, в которую записываются считанные символы
//! @param  size    Указатель на переменную, содержащую размер буфера, выделенного пользователем для хранения строки, в байтах
//! @param  file    Указатель на файл, из которого считывается строка
//!
//! @return Количество считанных символов строки (не включая нуль-байт) или -1, если при считывании произошла ошибка или по достижении конца файла не было считано ни одного символа
//!
//! @note   Функция продолжает считывание до символа перехода на следующую строку (который, если будет встречен, будет также внесен в считанную строку) или до конца файла
//! @note   Если str равен NULL, функция самостоятеьно выделит память для хранения считанной строки
//! @note   Если str указывает на буфер, размер которого (size) недостаточен для хранения считанной строки, функция расширит его при помощи функции realloc () (или аллоцирует новый буфер), обновив при необходимости значения str и size

ssize_t my_getline (char** str, size_t* size, FILE* file);

#endif